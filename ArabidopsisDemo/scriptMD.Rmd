---
title: "Plant single cell RNASeq analysis"
output: html_document
---

## 1. Set working directory
This is the folder on your computer that R uses to search and write files. 
You have to adjust this path to the folder on your computer that contains the data.
```{r}
# setwd("D:/Training/PlantDemo")
```

## 2. Load packages
Load the packages that you are going to use for the analysis in the memory of your computer.
```{r message=FALSE, warning=FALSE}
library(Seurat)
library(scater)
library(ggpubr)
library(dplyr)
```

## 3. Load data
Depending on the memory of your computer, you can choose to either start from the raw counts, or from the cellranger filtered counts.
While starting from the filtered count matrix reduces the need for a high-memory computer, you might potentially lose some cell types with lower gene expression.
For simplicity's sake however, we will continue here with the filtered count matrix.

Data can be loaded in 2 ways: 

-   Using the raw/filtered gene expression matrix  
-   Using the h5 file generated by CellRanger count

### Output generated by Cellranger starting from v3
-   **single and aggregated samples**: raw_feature_bc_matrix/ or filtered_feature_bc_matrix/
-   **H5** file: raw_feature_bc_matrix.h5 or filtered_feature_bc_matrix.h5

### Read expression matrices generated by Cellranger
Read10X() arguments:

- folder with output of Cellranger

The function returns a sparse matrix with the RNASeq data.
Depending on the genome that was used for mapping the reads, your genes can have different identifiers.
In the case of Arabidopsis TAIR10, gene column 1 contains the AGI, while gene column 2 contains the aliases.
To avoid confusion with aliases, we choose to use the AGI codes.

```{r}
data.RNA <- Read10X("TrainingData/filtered_feature_bc_matrix",gene.column = 1)
```

```{r}
saveRDS(data.RNA,file="RNA_matrix.rds")
```

#### Read h5-file generated by Cellranger v3
This code is used to read in an h5 file, but beware that h5 files by default only contain the alias as gene name.
```{r}
# rawData <- Read10X_h5("filtered_feature_bc_matrix.h5")
```

### Clean data

**How many genes are expressed in each cell?**  

- A gene is considered expressed when count > 0
- Cells are the columns in the count matrix hence MARGIN=2  
- sum(x > 0) calculates number of genes with non-zero counts
```{r}
cellCounts <- apply(data.RNA,2,function(x) sum(x > 0)) 
```

Cells with less than 300 expressed genes are removed.
```{r}
dim(data.RNA)
data.RNA <- data.RNA[,cellCounts>=300]
dim(data.RNA)
```

**For each gene: in how many cells is it expressed?**  

- A gene is considered expressed if count > 0  
- Genes are the rows in the count matrix hence MARGIN=1  
- sum(x > 0) calculates number of cells with non-zero counts
```{r}
geneCounts <- apply(data.RNA,1,function(x) sum(x > 0)) 
```

Genes that are expressed in less than 3 cells are removed.
```{r}
data.RNA <- data.RNA[geneCounts>=3,]
dim(data.RNA)
```

Remove obsolete variables
```{r}
rm(cellCounts)
rm(geneCounts)
saveRDS(data.RNA,file="RNA_clean.rds")
```

## 4. Convert to SingleCellExperiment object
In order to perform quality control using the scater package, the data needs to be in SingleCellExperiment format.
```{r}
sce <- SingleCellExperiment(assays=list(counts=data.RNA),mainExpName="RNA") 
rm(data.RNA)
```

## 5. Quality control of cells using scater
### Identify mitochondrial and chloroplast transcripts
Gene names are used as row names in the count matrix. To find the mitochondrial genes we need to look for row names that start with ATMG. Similar for chloroplast genes with ATCG.

grepl() checks if words contain a pattern and returns booleans:

- *^* in the pattern argument means starts with
- *ignore.case=TRUE*: make no distinction between lowercase ("AtMg") and uppercase ("ATMG") identifiers
```{r}
is.mito <- grepl("^ATMG",rownames(sce),ignore.case=TRUE)
is.cp <- grepl("^ATCG",rownames(sce),ignore.case=TRUE)
```

Mitochondrial and chloroplast genes can be used to identify unhealthy cells. When cells are exposed to stress, their cell membrane becomes leaky. When this happens:

- transcripts go through the tears in the membrane
- large mitochondria and chloroplasts/plastids stay inside the cell
- mitochondria and chloroplasts are the last organelles to degrade  

Enrichment of mitochondrial and chloroplast transcripts is therefore a clear indication of cellular stress.

### Calculate QC metrics per cell
Use addPerCellQC() from scater.  

Arguments of this function:

- *input*: count matrix
- *subsets*: a named list (objects in the list have labels) with names of genes that can be used as controls like mitochondrial and chloroplast genes
```{r}
sce <- addPerCellQC(sce,subsets=list(Mt=is.mito, Cp=is.cp))
```

The quality metrics are stored in the colData slot of sce 
```{r}
head(colData(sce),2) 
```

Nine quality metrics are calculated for every cell (=row), of which these are the most important:

- **detected**: number of expressed genes (count > 0)
- **sum**: number of transcripts (total count or library size)
- **subsets_Mt_percent**: percentage counts of mitochondrial genes
- **subsets_Cp_percent**: percentage counts of chloroplast genes  

## 6. Detect outliers cells using scater
Outlier cells are: 

1. cells with low number of genes (or UMIs) expressed 
2. cells with high percentage of mitochondrial/chloroplast transcripts

For percentage of mitochondrial/chloroplast reads, we prefer to work with fixed cut-offs, any cell above a certain percentage will be considered as damaged and removed from analysis.

isOutlier() can identify outlier cells for gene/UMI content, based on a certain number of MADs from the median. 
This is a trial and error process: 

- you choose a number of MADs
- create plots
- inspect the plots
- change the threshold for number of MADs
- repeat until it looks ok

Use isOutlier() from scater for the UMI counts. 
Arguments of this function:

- *input*: values for the metric you want to use
- *nmads*: threshold for number of MADs. The lower you set this, the more outliers will be found. 
- *type*: find outliers at both tails (default) or only at lower end (= too few) or only at higher end (= too many)
- *log*: do you want to take log10 of metric values before computing MAD?

**What to do when you have a large population of low-content cells?**
When you have a large population of lower-content cells, this will influence the median and you will not be able to remove these cells based on MADs alone.
In this case you can opt for a hard filter based on a fixed threshold, e.g. filter out any cell containing less than 1000 UMIs. However, this threshold is very dependent on your sequencing depth and some cell types by nature contain a lower gene content.
It's possible you will need to revisit these filtering steps if some cell types appear to be missing when you have generated a UMAP, or conversely, when a cluster exists containing significantly fewer UMIs than the other clusters.


### UMI counts per cell
```{r}
sce$nUMI.out.low <- isOutlier(sce$sum,nmads=2,type="lower",log=TRUE) 
sce$nUMI.out.high <- isOutlier(sce$sum,nmads=2,type="higher",log=TRUE)
sum(sce$nUMI.out.low | sce$nUMI.out.high)
```
### Number of expressed genes per cell
```{r}
sce$nGene.out.low <- isOutlier(sce$detected,nmads=2,type="lower",log=TRUE) 
sce$nGene.out.high <- isOutlier(sce$detected,nmads=2,type="higher",log=TRUE) 
sum(sce$nGene.out.low | sce$nGene.out.high)
```

**What causes extreme library sizes or number of expressed genes?**

- empty droplets 
- inefficient capture 
- doublets 
- cell damage

### Mitochondrial and chloroplast count percentages

The fixed cut-offs that you use for mitochondrial and chloroplast percentages should be dependent on the tissue type and biological context that you're investigating.
For example, in leaf tissue chloroplast content is generally higher in bundle sheath cells, so if you would choose the chloroplast threshold too low, you will erroneously remove the bundle sheath cells from the dataset.
In root tissue, chloroplast content is rather low, so by default we use 5% as threshold for mitochondrial content and 10% for chloroplast content.

```{r}
sce$mito.out.high <- sce$subsets_Mt_percent > 5
sum(sce$mito.out.high)
sce$cp.out.high <- sce$subsets_Cp_percent > 10 
sum(sce$cp.out.high)
```

### Create histograms

Calculate the cutoff value for outliers with respect to the number of UMIs.
```{r}
metaData <- as.data.frame(colData(sce))
cut.nUMI <- 2^(median(log2(metaData$sum))-2*mad(log2(metaData$sum),na.rm=TRUE))
ggplot(metaData,aes(sum)) + 
  geom_histogram(binwidth=100) + 
  xlab("Count depth (total UMI count)") +
  ylab("Frequency") +
  ggtitle("Histogram of total UMI count per cell") + 
  geom_vline(xintercept=cut.nUMI,color="red") +
  theme_bw()
```

Calculate the cutoff value for outliers with respect to the number of expressed genes
```{r}
cut.nGene <- 2^(median(log2(metaData$detected))-2*mad(log2(metaData$detected),na.rm=TRUE))
ggplot(metaData,aes(detected)) + 
  geom_histogram(binwidth=20) +
  xlab("Number of Genes") +
  ylab("Frequency") +
  ggtitle("Histogram of number of genes per cell") + 
  geom_vline(xintercept=cut.nGene,color="red") +
  theme_bw()
```

Plot the cutoff value for outliers with respect to expression of mitochondrial genes
```{r}
cut.mito <- 5
ggplot(metaData,aes(subsets_Mt_percent)) + 
  geom_histogram(binwidth=0.1) +
  xlab("% Mitochondrial counts") +
  ylab("Frequency") +
  ggtitle("Histogram of % mitochondrial genes per cell") +
  geom_vline(xintercept=cut.mito,color="red") +
  theme_bw()
```

Plot the cutoff value for outliers with respect to expression of chloroplast genes
```{r}
cut.cp <- 10
ggplot(metaData,aes(subsets_Cp_percent)) + 
  geom_histogram(binwidth=0.1) +
  xlab("% Chloroplast counts") +
  ylab("Frequency") +
  ggtitle("Histogram of % chloroplast genes per cell") +
  geom_vline(xintercept=cut.cp,color="red") +
  theme_bw()
```
### Create violin plots 
####Before filtering
```{r}
ggplot(metaData,aes("",sum)) +
  geom_jitter(height=0,width=0.3,aes(color=nUMI.out.low)) +
   geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Total UMI counts per cell") +
  theme_classic()
```
```{r}
ggplot(metaData,aes("",detected)) +
  geom_jitter(height=0,width=0.3,aes(color=nGene.out.low)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Number of genes per cell") +
  theme_classic()
```

```{r}
ggplot(metaData,aes("",subsets_Mt_percent)) +
  geom_jitter(height=0,width=0.3,aes(color=mito.out.high)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("% mitochondrial genes per cell") +
  theme_classic()
```

```{r}
ggplot(metaData,aes("",subsets_Cp_percent)) +
  geom_jitter(height=0,width=0.3,aes(color=cp.out.high)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("% chloroplast genes per cell") +
  theme_classic()
```

#### After filtering
Select the cells that are not defined as outliers
```{r}
non.out <- !(metaData$nUMI.out.low | metaData$nUMI.out.high | metaData$nGene.out.low | metaData$nGene.out.high | metaData$mito.out.high | metaData$cp.out.high)
metaData.filtered <- metaData[non.out,]
dim(metaData.filtered)
```
```{r}
ggplot(metaData.filtered,aes("",sum)) +
  geom_jitter(height=0,width=0.3,aes(color=nUMI.out.low)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Total UMI counts per cell after filtering") +
  theme_classic()
```
```{r}
ggplot(metaData.filtered,aes("",detected)) +
  geom_jitter(height=0,width=0.3,aes(color=nGene.out.low)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Number of genes per cell after filtering") +
  theme_classic()
```
```{r}
ggplot(metaData.filtered,aes("",subsets_Mt_percent)) +
  geom_jitter(height=0,width=0.3,aes(color=mito.out.high)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("% mitochondrial genes per cell after filtering") +
  theme_classic()
```
```{r}
ggplot(metaData.filtered,aes("",subsets_Cp_percent)) +
  geom_jitter(height=0,width=0.3,aes(color=cp.out.high)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("% chloroplast genes per cell after filtering") +
  theme_classic()
```

### Remove outliers
Cells with quality values below the thresholds are considered outliers. 
They are removed under the assumption that they correspond to low-quality cells.  

To this end we will keep all cells that are not marked as outlier.
```{r}
keep <- !(metaData$nUMI.out.low | metaData$nUMI.out.high | metaData$nGene.out.low | metaData$nGene.out.high | metaData$mito.out.high | metaData$cp.out.high) 
dim(sce)
sce <- sce[,keep] 
dim(sce)
```
```{r}
rm(metaData.filtered)
rm(metaData)
rm(keep)
rm(non.out)
saveRDS(sce,file="sce_filtered.rds")
```

## 7. Create Seurat object
A Seurat object is a data type with slots to store the raw single cell RNASeq data and the analysis results. It simplifies the analysis because you do not need to keep track of many individual variables. They are all collapsed into one single Seurat object.  

Seurat objects contain: 

- 1 set of cells 
- 1 or more assays objects (=individual sets of count data)  

They can be reduced from high dimension to lower-dimension state. The results of such a dimensionality reduction are stored in the Seurat object as DimReduc objects.  

Seurat objects also store meta data.

The various slots are accessible via @sign.  
Use CreateSeuratObject() from Seurat.

Arguments of this function:

- *counts*: input data
- *min.cells*: remove genes expressed in less than this many cells
- *min.features*: remove cells with less than this many genes expressed  
We are not going to use the two latter arguments because we already filtered low quality cells and genes with scater.

```{r}
sce <- readRDS("sce_filtered.rds")
counts <- counts(sce)
rownames(counts) <- rownames(sce)
colnames(counts) <- colnames(sce)
metaData <- colData(sce) 
rm(sce)
seuratObj <- CreateSeuratObject(counts=counts,project = "Demo")
seuratObj <- AddMetaData(seuratObj,as.data.frame(metaData)) 
rm(counts)
```

## 8. Normalization
By default Seurat uses global-scaling normalization (Log-Normalize)

1. Divide each count by the total number of counts in that cell  
This changes all counts into a relative measure.  
Mainly technical factors cause variations in the number of reads per cell, although biological factors also play a smaller role.

2. Multiply this relative measure by the scale factor (10,000 by default)

3. Log-transforms the result to stabilize the variance  

Use NormalizeData() from Seurat.  

Arguments of this function: 

- *normalization.method*: default is
log-normalization: scale all cells to 10000 reads and do a log transformation
- *scale.factor*: default scales all cells to 10000 reads
```{r}
seuratObj <- NormalizeData(object=seuratObj)
```

## 9. Find highly variable genes (HVGs)
HVGs are genes with high variability (high meaning above background level).  

Spike-in transcripts can be used to estimate the background level but Seurat can calculate HVGs based on the data when spike-ins are not available.

Use FindVariableFeatures() from Seurat. 

Arguments for this function:

- *object* input is Seurat object
- *selection.method*: default vst stabilizes variance  
- *nfeatures*: default identify the 2000 most variable genes. This is a typical settings for UMI data that is normalized to a total of 10000 counts
- *verbose*: default print info about progress of calculations in the console
```{r}
seuratObj <- FindVariableFeatures(object=seuratObj)
length(VariableFeatures(seuratObj)) 
```
**Get info on these HVGs** (mean,dispersion,dispersion scaled)
```{r}
print(head(HVFInfo(seuratObj)))
```

**Plot variable genes**
```{r}
VariableFeaturePlot(object=seuratObj)
```

## 10. Scaling
Standard pre-processing step prior to PCA  
Scaling will shift expression of each gene so that:

- mean expression across cells is 0 
- variance across cells is 1 
This will avoid that highly-expressed genes dominate the PCA  

Arguments for this function:

- *object*: Seurat object 
- *features*: which genes need to be scaled? By default the 2000 most variable genes. 

```{r}
seuratObj <- ScaleData(object=seuratObj)
```

## 8+9+10bis. SCTransform
SCTransform is an alternative to the NormalizeData(), FindVariableFeatures() and ScaleData() commands.
Instead of working on the default RNA assay, it adds a new SCT-assay to the Seurat object.
See https://satijalab.org/seurat/articles/sctransform_vignette.html for more information.

```{r}
#seuratObj <- SCTransform(object=seuratObj)
```

## 11. PCA 
Use RunPCA() from Seurat to calculate the first 50 principal components. Usually not all of these will be informative, so in later steps you can decide how many of these PCs will be used.

Arguments of the function: 
- input: scaled counts of HVGs 
- *features*: which genes to use for PCA (the 2000 HVGs)
- *npcs*: number of PCs to calculate 
- *ndims.print*: number of PCs with highest variability to show genes with heighest weights for, here: PC1, PC2, PC3, PC4, PC5 
- *nfeatures.print*: number of genes with heighest weights to print for these 5 PCs
- *reduction.name*: default name for the PCA results is **pca**
- *reduction.key*: default name for each PC starts with **PC_** so PC_1, PC_2, PC_3...
```{r}
seuratObj <- RunPCA(object=seuratObj, features=VariableFeatures(seuratObj),
    npcs=50,ndims.print=1:5,nfeatures.print=10)
```
Results are stored in the pca object of the reductions slot  

Plots of the PCs can be made using DimPlot()  
Arguments of this function:

- *object* Seurat object, input are the dimensionality reduction results
- *reduction* use results of which dimensionality reduction: UMAP, tSNE or PCA?
- *group.by* how to color the cells (the dots on the plot)?
- *split.by* create multiple plots e.g. one for control and one for treatment. The value is the name of the column in the meta data that defines the groups.
- *dims* which PCs to plot? default is PC_1 versus PC_2
- *label*: default do not put cluster labels on the plot
- *label.size*: font size of cluster labels
- *pt.size*: size of the points
```{r}
names(seuratObj)
seuratObj@reductions$pca@feature.loadings[1:5,1:5]
DimPlot(object=seuratObj,reduction="pca")
```

## 12. Elbow plot of the PCs
Create a PC Elbow plot using ElbowPlot(): a ranking of the PCs based on the percentage of variance explained by each PC to find a cutoff for the p-value.  

Basically, you see where the plot flattens (= elbow)  

Use this plot to determine the number of PCs to use for further analysis. If you select too few PCs, your visualisation will not contain all necessary information, e.g. for rare cell types. If you select a few too many, this is usually not a problem, you might just add a bit more noise. Don't go too high by default because this will also increase computational requirements in later steps and you might add a lot of noise to the data visualisation.   

Arguments of this function:

- *object* Seurat object, input are the PC calculations
- *ndims* default show 20 PCs on the plot
- *reduction* default show PCs obtained by PCA
```{r}
ElbowPlot(object=seuratObj,ndims=50)
```

Based on this plot, we can usually see that the top 20 PCs retain a lot of information, while other PCs contain progressively less. However, it is still advisable to use more PCs since they might contain information about rare cell types.

Based on this we select a final number of PCs to use in further steps.

## 13. Clustering 
```{r}
dimsToTry <- 30
```

We will construct a k-nearest neighbour graph in order to perform a clustering on the graph. This can be generalized as 3 main steps:

- Build a kNN graph from the data

- Prune spurious connections from kNN graph (optional step). This is a SNN graph.

- Find groups of cells that maximizes the connections within the group compared other groups.

### Building kNN/SNN graph
To construct a kNN graph, we calculate the Euclidean distance between cells in the PCA space. So we will only use the top N PCA dimensions. We will use the same dimensions for computing UMAP/tSNE.

For every cell we are going to find its nearest neighbors (the smallest Euclidean distance), the most similar cells (in terms of gene expression).  

Use FindNeighbors() from Seurat to compute both the kNN and SNN graphs, in which we refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity).

Arguments for this function: 

- *dims*: how many PCs to use (cutoff)
- *k-param*: by default the 20 nearest neighbors are identified for each cell
- *prune.SNN*: by default stringency of overlap removal is 1/15 (0=no pruning ; 1=prune everything). Overlaps between cell neighborhoods are removed in the SNN graph.

```{r}
seuratObj <- FindNeighbors(object=seuratObj, dims=1:dimsToTry)
```

The kNN graph is a matrix where every connection between cells is represented as a 1. This is called an unweighted graph (default in Seurat). Some cell connections can have more importance than others, in that case the scale of the graph goes from 0 to a maximum distance (it's these weights that are calculated based on the overlaps in local neighbourhoods). Usually, the smaller the distance, the closer two points are, the stronger is their connection. This is called a weighted graph. Both weighted and unweighted graphs are suitable for clustering, but clustering on unweighted graphs is faster for large datasets (> 100k cells).  

### Graph-based clustering
Then we are going to find clusters based on the neighbors info. Cells are iteratively grouped together. 

In Seurat, FindClusters() will do a graph-based clustering.

```{r}
resToUse <- 0.8 
```

Arguments for this function: 

- *object* Seurat object, input are the neighborhood graphs 
- *resolution*: how coarse you want the clustering to be. Higher values create more clusters. Recommendation here: try different values until you get a good tSNE/clustering with biologically meaningful results (between 0.4-1.2 for 3K cells). Usually 0.8 is a good resolution to start with.
- *algorithm* by default the "Louvain" algorithm is used for clustering (1). TO use the leiden algorithm, you need to set *algorithm*=4. 
- *graph.name* which graph to use: kNN or SNN

```{r}
seuratObj <- FindClusters(object=seuratObj, resolution=resToUse,graph.name="RNA_snn") 
```

The cluster data is stored in the metadata slot
```{r}
head(seuratObj@meta.data) 
```

If you change dimsToTry and run the clustering again the old cluster data is overwritten  
If you change the resolution and run the clustering again the new cluster data is added to the metadata. The results of the last clustering will be in the "seurat_clusters" column and used for downstream analysis.


## 14. Create tSNE plot
Dimensionality reduction using RunTSNE()  

Arguments of this function:  

- *object* Seurat object, input are typically the PCs
- *reduction* default use PCs obtained by PCA as input
- *dims* default use the first five PCs as input
- *check_duplicates* tSNE will generate an error "duplicates (cells with exactly the same PC coordinates) have to be removed before running tSNE" if there are duplicate cells in the data set. You can avoid this error by setting this parameter to FALSE.  

As input use the same PCs as in the clustering
```{r}
seuratObj <- RunTSNE(object=seuratObj,dims=1:dimsToTry,check_duplicates=FALSE)
```

```{r}
DimPlot(seuratObj,reduction="tsne",label=TRUE, label.size=8,pt.size=2) + NoLegend()
```

To color cells from different samples differently
```{r}
DimPlot(seuratObj,reduction="tsne",pt.size=2,group.by="orig.ident")
```

## 15. Create UMAP plot
Dimensionality reduction using RunUMAP()  

Arguments of this function
- *object* Seurat object, input are typically the PCs
- *reduction* default use PCs obtained by PCA as input
- *dims* which PCs to use as input
- *n.components* default reduce to 2 dimensions. If you want to create a 3D visualisation, this should be 3.
- *n.neighbors* parameter of the dimensionality reduction method. Larger values will preserve more global structure at the loss of detailed local structure. This parameter should be in the range 5 to 50, default is 30.
- *n.epochs* parameter of the dimensionality reduction method. Larger values result in higher accuracy. By default value will be selected based on the size of the input dataset (200 for large datasets, 500 for small).
- *min.dist* parameter of the dimensionality reduction method. How tightly can points be compressed together. Larger values ensure points are more evenly distributed, while smaller values allow to optimize more accurately with regard to local structure. Sensible values are in the range 0.001 to 0.5, default is 0.3
- *spread* parameter of the dimensionality reduction method. The effective scale of the points. In combination with *min.dist* this determines how clustered/clumped the points are.

```{r}
seuratObj <- RunUMAP(seuratObj,dims=1:dimsToTry)
```

In a UMAP plot distances between clusters are more meaningful than in a tSNE plot.
```{r}
DimPlot(object=seuratObj,reduction="umap",label=TRUE,label.size=8) + NoLegend() + ggplot2::ggtitle(label="UMAP_on_PCA")
```

Visualize UMAP plot, colored by sample to check for batch effects
```{r}
DimPlot(object=seuratObj,group.by="orig.ident")
```

## 16. Interpret the clustering
Specify the clustering you want to use and print how many cells each cluster contains 

```{r}
#Idents(seuratObj) <- "RNA_snn_res.0.8"
table(seuratObj@active.ident)
```
You can also add external metadata from e.g. a .csv file.

```{r}
annotations <- read.csv("TrainingData/annotation_Demo.csv",row.names = 1,header = F)
seuratObj$annotation <- annotations
```

Plot the clustering and annotations

```{r}
p1 <- DimPlot(seuratObj,label=TRUE) + NoAxes()
p2 <- DimPlot(seuratObj,group.by="annotation",label=T,repel=T) + NoAxes()
ggarrange(p1,p2)
```

Plot the number of UMIs versus clusters to check if there is no clustering based on UMI content. If this is the case, you might have to alter the filtering steps and start again from there.

```{r}
p1 <- DimPlot(seuratObj,label=TRUE) + NoAxes()
p3 <- FeaturePlot(seuratObj,"sum",cols=c("darkblue","yellow"),pt.size=1) + NoAxes() +ggtitle("Number of UMIs")
ggarrange(p1,p3)
```


## 17. Save Seurat object 
Save object so that 

- it can easily be loaded back without having to rerun these computationally intensive steps  
- it's easy to share with collaborators  
```{r}
saveRDS(seuratObj,file="seuratObj.rds")
```

