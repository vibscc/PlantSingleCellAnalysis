---
title: "Plant single cell RNASeq analysis"
output: html_document
---

## 1. Set working directory
This is the folder on your computer that R uses to search and write files. 
You have to adjust this path to the folder on your computer that contains the data.
```{r}
#setwd("D:/Training/PlantDemo")
```

## 2. Load packages
Load the packages that you are going to use for the analysis in the memory of your computer.
```{r message=FALSE, warning=FALSE}
library(Seurat)
library(scater)
library(VennDiagram)
library(ggpubr)
library(dplyr)
```

## 3. Load data
Depending on the memory of your computer, you can choose to either start from the raw counts, or from the cellranger filtered counts.
While starting from the filtered count matrix reduces the need for a high-memory computer, you might potentially lose some cell types with lower gene expression.
For simplicity's sake, we will continue here with the filtered count matrix.

Data can be loaded in 2 ways: 

-   Using the raw/filtered gene expression matrix  
-   Using the h5 file generated by CellRanger count

### Output generated by Cellranger starting from v3
-   **single and aggregated samples**: raw_feature_bc_matrix/ or filtered_feature_bc_matrix/
-   **H5** file: raw_feature_bc_matrix.h5 or filtered_feature_bc_matrix.h5

### Read expression matrices generated by Cellranger
Read10X() arguments:

- folder with output of Cellranger

The function returns a sparse matrix with the RNASeq data.
Depending on the genome that was used for mapping the reads, your genes can have different identifiers.
In the case of Arabidopsis TAIR10, gene column 1 contains the AGI, while gene column 2 contains the aliases.
To avoid confusion with aliases, we choose to use the AGI codes.

```{r}
data.RNA <- Read10X("TrainingData/filtered_feature_bc_matrix",gene.column = 1)
```

```{r}
saveRDS(data.RNA,file="RNA_matrix.rds")
```

#### Read h5-file generated by Cellranger v3
This code is used to read in a h5 file, but beware that h5 files by default only contain the alias as gene name.
```{r}
# rawData <- Read10X_h5("filtered_feature_bc_matrix.h5")
```

### Clean data

**How many genes are expressed in each cell?**  

- A gene is considered expressed when count > 0
- Cells are the columns in the count matrix hence MARGIN=2  
- sum(x > 0) calculates number of genes with non-zero counts
```{r}
cellCounts <- apply(data.RNA,2,function(x) sum(x > 0)) 
```

Cells with less than 300 expressed genes are removed.
```{r}
dim(data.RNA)
data.RNA <- data.RNA[,cellCounts>=300]
dim(data.RNA)
```

**For each gene: in how many cells is it expressed?**  

- A gene is considered expressed if count > 0  
- Genes are the rows in the count matrix hence MARGIN=1  
- sum(x > 0) calculates number of cells with non-zero counts
```{r}
geneCounts <- apply(data.RNA,1,function(x) sum(x > 0)) 
```

Genes that are expressed in less than 3 cells are removed.
```{r}
data.RNA <- data.RNA[geneCounts>=3,]
dim(data.RNA)
```

Remove obsolete variables
```{r}
rm(cellCounts)
rm(geneCounts)
saveRDS(data.RNA,file="RNA_clean.rds")
```

## 4. Convert to SingleCellExperiment object
```{r}
sce <- SingleCellExperiment(assays=list(counts=data.RNA),mainExpName="RNA") 
rm(data.RNA)
```

## 5. Quality control of cells using scater
### Identify mitochondrial and chloroplast transcripts
Gene names are used as row names in the count matrix. To find the mitochondrial genes we need to look for row names that start with ATMG. Similar for chloroplast genes with ATCG.

grepl() checks if words contain a pattern and returns booleans:

- *^* in the pattern argument means starts with
- *ignore.case=TRUE*: make no distinction between lowercase ("AtMg") and uppercase ("ATMG") identifiers
```{r}
is.mito <- grepl("^ATMG",rownames(sce),ignore.case=TRUE)
is.cp <- grepl("^ATCG",rownames(sce),ignore.case=TRUE)
```

Mitochondrial and chloroplast genes can be used to identify unhealthy cells. When cells are exposed to stress, their cell membrane becomes leaky. When this happens:

- transcripts go though the tears in the membrane
- large mitochondria and chloroplasts/plastids stay inside the cell
- mitochondria and chloroplasts are the last organelles to degrade  

Enrichment of mitochondrial and chloroplast transcripts is therefore a clear indication of cellular stress.

### Calculate QC metrics per cell
Use addPerCellQC() from scater.  

Arguments of this function:

- *input*: count matrix
- *subsets*: a named list (objects in the list have labels) with names of genes that can be used as controls like mitochondrial and chloroplast genes
```{r}
sce <- addPerCellQC(sce,subsets=list(Mt=is.mito, Cp=is.cp))
```

The quality metrics are stored in the colData slot of sce 
```{r}
head(colData(sce),2) 
```

Six quality metrics are calculated for every cell (=row):

- **detected**: number of expressed genes (count > 0)
- **sum**: number of transcripts (total count or library size)
- **subsets_Mt_percent**: percentage counts of mitochondrial genes
- **subsets_Cp_percent**: percentage counts of chloroplast genes  

## 6. Detect outliers cells using scater
Outlier cells are: 

1. cells with low number of genes (or UMIs) expressed 
2. cells with high percentage of mitochondrial/chloroplast transcripts

For percentage of mitochondrial/chloroplast reads, we prefer to work with fixed cut-offs, any cell above a certain percentage will be considered as damaged and removed from analysis.
isOutlier() can identify outlier cells for gene/UMI content, based on a certain number of MADs from the median. 

This is a trial and error process: 

- you choose a number of MADs
- create plots
- inspect the plots
- change the threshold for number of MADs
- repeat until it looks ok

Use isOutlier() from scater for the UMI counts. 
Arguments of this function:

- *input*: values for the metric you want to use
- *nmads*: threshold for number of MADs. The lower you set this, the more outliers will be found. 
- *type*: find outliers at both tails (default) or only at lower end (= too few) or only at higher end (= too many)
- *log*: do you want to take log10 of metric values before computing MAD?

### UMI counts per cell
```{r}
sce$nUMI.out.low <- isOutlier(sce$sum,nmads=3,type="lower",log=TRUE) 
sce$nUMI.out.high <- isOutlier(sce$sum,nmads=3,type="higher",log=TRUE)
sum(sce$nUMI.out.low | sce$nUMI.out.high)
```

### Number of expressed genes per cell
```{r}
sce$nGene.out.low <- isOutlier(sce$detected,nmads=3,type="lower",log=TRUE) 
sce$nGene.out.high <- isOutlier(sce$detected,nmads=3,type="higher",log=TRUE) 
sum(sce$nGene.out.low | sce$nGene.out.high)
```

**What causes extreme library sizes or number of expressed genes?**

- empty droplets 
- inefficient capture 
- doublets 
- cell damage

### Mitochondrial and chloroplast count percentages

The fixed cut-offs that you use for mitochondrial and chloroplast percentages should be dependent on the tissue type and biological context that you're investigating.
For example, in leaf tissue chloroplast content is generally higher in bundle sheath cells, so if you would choose the chloroplast threshold too low, you will erroneously remove the bundle sheath cells from the dataset.
In root tissue, chloroplast content is rather low, so by default we use 5% as threshold for mitochondrial content and 10% for chloroplast content.

```{r}
sce$mito.out.high <- sce$subsets_Mito_percent > 5 
sum(sce$mito.out.high)
sce$cp.out.high <- sce$subsets_Cp_percent > 10 
sum(sce$cp.out.high)
```

### Create histograms
```{r}
metaData <- as.data.frame(colData(sce))
ggplot(metaData,aes(sum)) + 
  geom_histogram(binwidth=100) + 
  xlab("Count depth (total UMI count)") +
  ylab("Frequency") +
  ggtitle("Histogram of total UMI count per cell") + 
  theme_bw()
```

Calculate the cutoff value for outliers with respect to the  number of expressed genes
```{r}
cut.nGene <- 2^(median(log2(metaData$detected))-3*mad(log2(metaData$detected),na.rm=TRUE))
ggplot(metaData,aes(nGene)) + 
  geom_histogram(binwidth=20) +
  xlab("Number of Genes") +
  ylab("Frequency") +
  ggtitle("Histogram of number of genes per cell") + 
  geom_vline(xintercept=cut.nGene,color="red") +
  theme_bw()
```

Plot the cutoff value for outliers with respect to expression of mitochondrial genes
```{r}
cut.mito <- 5
ggplot(metaData,aes(subsets_Mito_percent)) + 
  geom_histogram(binwidth=0.1) +
  xlab("% Mitochondrial counts") +
  ylab("Frequency") +
  ggtitle("Histogram of % mitochondrial genes per cell") +
  geom_vline(xintercept=cut.mito,color="red") +
  theme_bw()
```

Plot the cutoff value for outliers with respect to expression of chloroplast genes
```{r}
cut.cp <- 10
ggplot(metaData,aes(subsets_Cp_percent)) + 
  geom_histogram(binwidth=0.1) +
  xlab("% Chloroplast counts") +
  ylab("Frequency") +
  ggtitle("Histogram of % chloroplast genes per cell") +
  geom_vline(xintercept=cut.cp,color="red") +
  theme_bw()
```
### Create violin plots 
####Before filtering
```{r}
ggplot(metaData,aes("",sum)) +
  geom_jitter(height=0,width=0.3,aes(color=nUMI.out.low)) +
   geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Total UMI counts per cell") +
  theme_classic()
```
```{r}
ggplot(metaData,aes("",detected)) +
  geom_jitter(height=0,width=0.3,aes(color=nGene.out.low)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Number of genes per cell") +
  theme_classic()
```

```{r}
ggplot(metaData,aes("",subsets_Mito_percent)) +
  geom_jitter(height=0,width=0.3,aes(color=mito.out.high)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("% mitochondrial genes per cell") +
  theme_classic()
```

```{r}
ggplot(metaData,aes("",subsets_Cp_percent)) +
  geom_jitter(height=0,width=0.3,aes(color=cp.out.high)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("% chloroplast genes per cell") +
  theme_classic()
```

#### After filtering
Select the cells that are not defined as outliers
```{r}
non.out <- !(metaData$nUMI.out.low | metaData$nUMI.out.high | metaData$nGene.out.low | metaData$nGene.out.high | metaData$mito.out.high | metaData$cp.out.high)
metaData.filtered <- metaData[non.out,]
dim(metaData.filtered)
```
```{r}
ggplot(metaData.filtered,aes("",sum)) +
  geom_jitter(height=0,width=0.3,aes(color=nUMI.out.low)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Total UMI counts per cell after filtering") +
  theme_classic()
```
```{r}
ggplot(metaData.filtered,aes("",detected)) +
  geom_jitter(height=0,width=0.3,aes(color=nGene.out.low)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Number of genes per cell after filtering") +
  theme_classic()
```
```{r}
ggplot(metaData.filtered,aes("",subsets_Mito_percent)) +
  geom_jitter(height=0,width=0.3,aes(color=mito.out.high)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("% mitochondrial genes per cell after filtering") +
  theme_classic()
```

```{r}
ggplot(metaData.filtered,aes("",subsets_Cp_percent)) +
  geom_jitter(height=0,width=0.3,aes(color=cp.out.high)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("% chloroplast genes per cell after filtering") +
  theme_classic()
```

### Remove outliers
Cells with quality values below the thresholds are considered outliers. 
They are removed under the assumption that they correspond to low-quality cells.  

To this end we will keep all cells that are not marked as outlier.
```{r}
keep <- !(metaData$nUMI.out.low | metaData$nUMI.out.high | metaData$nGene.out.low | metaData$nGene.out.high | metaData$mito.out.high | metaData$cp.out.high) 
dim(sce)
sce <- sce[,keep] 
dim(sce)
```
```{r}
rm(metaData.filtered)
rm(metaData)
rm(keep)
rm(non.out)
saveRDS(sce,file="sce_filtered.rds")
```

## 8. Create Seurat object
A Seurat object is a data type with slots to store the raw single cell RNASeq data and the analysis results. It simplifies the analysis because you do not need to keep track of many individual variables. They are all collapsed into one single Seurat object.  

Seurat objects contain: 

- 1 set of cells 
- 1 or more assays objects (=individual sets of count data)  

They can be reduced from high dimension to lower-dimension state. The results of such a dimensionality reduction are stored in the Seurat object as DimReduc objects.  

Seurat objects also store meta data.  

The various slots are accessible via @sign.  
Use CreateSeuratObject() from Seurat.

Arguments of this function:

- *counts*: input data
- *min.cells*: remove genes expressed in less than this many cells
- *min.features*: remove cells with less than this many genes expressed  
We are not going to use the two latter arguments because we already filtered low quality cells and genes with scater.

```{r}
seuratObj <- CreateSeuratObject(counts=counts(sce))
seuratObj <- AddMetaData(seuratObj,as.data.frame(metaData)) 
rm(sce)
```

## 9. Normalization
By default Seurat uses global-scaling normalization (Log-Normalize)

1. Divide each count by the total number of counts in that cell  
This changes all counts into a relative measure.  
Mainly technical factors cause variations in the number of reads per cell, although biological factors also play a smaller role.

2. Multiply this relative measure by the scale factor (10,000 by default)

3. Log-transforms the result to stabilize the variance  

Use NormalizeData() from Seurat.  

Arguments of this function: 

- *normalization.method*: default is
log-normalization: scale all cells to 10000 reads and do a log transformation
- *scale.factor*: default scales all cells to 10000 reads
```{r}
seuratObj <- NormalizeData(object=seuratObj)
```
**Where are these log normalized values?**
Raw counts are in the counts slot of the RNA object
```{r}
seuratObj@assays$RNA@counts[1:5,1:10]
```

Normalized counts are in the data slot
```{r}
seuratObj@assays$RNA@data[1:5,1:10]
```

Retrieve the counts for 1 gene
```{r}
gene3.raw <- seuratObj@assays$RNA@counts[3,]
gene3.norm <- seuratObj@assays$RNA@data[3,]
sum(gene3.raw!=gene3.norm)
```

**Histogram of raw library sizes**
```{r}
ggplot(seuratObj@meta.data,aes(nUMI)) + geom_histogram(bins=60)
```

**Histogram of normalized library sizes**
```{r}
counts.norm <- as.matrix(seuratObj@assays$RNA@data)
nUMILN <- data.frame(nUMI=colSums(counts.norm))
ggplot(nUMILN,aes(nUMI)) + geom_histogram(bins=60)
```

## 11. Find highly variable genes
HVGs are genes with high variability (high meaning above background level).  

Spike-in transcripts can be used to estimate the background level but Seurat can calculate HVGs based on the data when spike-ins are not available.  

Use FindVariableFeatures() from Seurat. 

Arguments for this function:

- *object* input is Seurat object
- *selection.method*: default vst stabilizes variance  
- *nfeatures*: default identify the 2000 most variable genes. This is a typical settings for UMI data that is normalized to a total of 10000 counts
- *verbose*: default print info about progress of calculations in the console
```{r}
seuratObj <- FindVariableFeatures(object=seuratObj)
length(VariableFeatures(seuratObj)) 
```
**Get info on these HVGs** (mean,dispersion,dispersion scaled)
```{r}
print(head(HVFInfo(seuratObj)))
```

**Plot variable genes**
```{r}
VariableFeaturePlot(object=seuratObj)
```

### Questions
- Select the 20 most variable genes 
Hint: use VariableFeatures(seuratObj)
- Add the names of these 20 genes to the plot
Hint: use LabelPoints() and output of previous question as value for points

## 12. Scaling
Standard pre-processing step prior to PCA  
Scaling will shift expression of each gene so that:

- mean expression across cells is 0 
- variance across cells is 1 
This will avoid that highly-expressed genes dominate the PCA  

Arguments for this function:

- *object*: Seurat object 
- *features*: which genes need to be scaled? default the 2000 most variable genes. 

```{r}
seuratObj <- ScaleData(object=seuratObj)
```

Scaled values are in the scale.data slot of the RNA object
```{r}
seuratObj@assays$RNA@scale.data[1:5,1:4]
```

### Questions
- What is the name of the gene with the highest raw count in cell 1?
- What is the raw count of this gene in cell 1?
- What is the name of the gene with the highest normalized count in cell 1?
- What is the normalized count of this gene in cell 1?
- What is the total normalized count of cell 1?
- What is the standardized variance of gene Ubr7?
- What is the name of the gene with the highest standardized variance?
- What is the standardized variance of this gene?
- What is the scaled count of gene Gzma in cell 1?
- How to regress out percentage of mitochondrial transcripts and library size?

## 13. PCA 
Use RunPCA() from Seurat

Arguments of the function: 
- input: scaled counts of HVGs 
- *features*: which genes to use for PCA (the 2000 HVGs)
- *npcs*: number of PCs to calculate 
- *ndims.print*: number of PCs with highest variability to show genes with heighest weights for, here: PC1, PC2, PC3, PC4, PC5 
- *nfeatures.print*: number of genes with heighest weights to print for these 5 PCs
- *reduction.name*: default name for the PCA results is **pca**
- *reduction.key*: default name for each PC starts with **PC_** so PC_1, PC_2, PC_3...
```{r}
seuratObj <- RunPCA(object=seuratObj,               features=VariableFeatures(seuratObj),
    npcs=50,ndims.print=1:5,nfeatures.print=10)
```
Results are stored in the pca object of the reductions slot  

Plots of the PCs can be made using DimPlot()  
Arguments of this function:

- *object* Seurat object, input are the dimensionality reduction results
- *reduction* use results of which dimensionality reduction: UMAP, tSNE or PCA?
- *group.by* how to color the cells (the dots on the plot)?
- *split.by* create multiple plots e.g. one for KO and one for WT. The value is the name of the column in the meta data that defines the groups.
- *dims* which PCs to plot? default is PC_1 versus PC_2
- *label*: default do not put cluster labels on the plot
- *label.size*: font size of cluster labels
- *pt.size*: size of the points
```{r}
names(seuratObj)
seuratObj@reductions$pca@cell.embeddings[1:5,1:5]
class(seuratObj@reductions$pca)
seuratObj@reductions$pca@feature.loadings[1:5,1:5]
DimPlot(object=seuratObj,reduction="pca",group.by="sample")
```

If you see separate clusters for the different conditions you need to integrate the cells across conditions (see later)

### Questions
- Visualize which genes contribute most to the first 5 PCs
Hint: use VizDimLoadings() and set balanced=TRUE

## 14. Heat maps of the PCs
Create a heatmap for PCs 1-36: one heatmap per PC  
The counts of the genes determine the color on the heat map

Arguments for the DimHeatmap() function: 

- *dims*: which PCs to plot 
- *cells*: how many cells to plot 
- *balanced*: plot equal number of genes with highest and lowest weights? 
- *fast=FALSE*: nicer and customizable plot with
ggplot2 but much slower to make
```{r}
DimHeatmap(seuratObj,dims=1:12,cells=500,balanced=TRUE)
```

The more PCs you plot the less clear the plots become: you start seeing noise.
```{r}
DimHeatmap(seuratObj,dims=13:24,cells=500,balanced=TRUE)
DimHeatmap(seuratObj,dims=25:36,cells=500,balanced=TRUE)
```

## 15. Elbow plot of the PCs
Create a PC Elbow plot using ElbowPlot(): a ranking of the PCs based on the percentage of variance explained by each PC to find a cutoff for the p-value.  

Basically, you see where the plot flattens (= elbow)  

Use this plot in combination with the PC heatmap to determine the number of PCs to use for further analysis  

Arguments of this function:

- *object* Seurat object, input are the PC calculations
- *ndims* default show 20 PCs on the plot
- *reduction* default show PCs obtained by PCA
```{r}
ElbowPlot(object=seuratObj,ndims=50)
```

Based on this plot, we can see that the top 20 PCs retain a lot of information, while other PCs contain progressively less. However, it is still advisable to use more PCs since they might contain information about rare cell types.

Based on all plots combined we choose the cutoff at PC40.

## 16. Clustering 
```{r}
dimsToTry <- 30
```

We will construct a k-nearest neighbour graph in order to perform a clustering on the graph. This can be generalized as 3 main steps:

- Build a kNN graph from the data

- Prune spurious connections from kNN graph (optional step). This is a SNN graph.

- Find groups of cells that maximizes the connections within the group compared other groups.

### Building kNN/SNN graph
To construct a kNN graph, we calculate the Euclidean distance between cells in the PCA space. So we will only use the top N PCA dimensions. We will use the same dimensions for computing UMAP/tSNE.

For every cell we are going to find its nearest neighbors (the smallest Euclidean distance), the most similar cells (in terms of gene expression).  

Use FindNeighbors() from Seurat to computes both the kNN and SNN graphs, in which we refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity).

Arguments for this function: 

- *dims*: how many PCs to use (cutoff). Recommendation here: as long as you get extra clusters increase the number of PCs 
- *k-param*: by default the 20 nearest neighbors are identified for each cell
- *prune.SNN*: by default stringency of overlap removal is 1/15 (0=no pruning ; 1=prune everything). Overlaps between cell neighborhoods are removed in the SNN graph.

```{r}
seuratObj <- FindNeighbors(object=seuratObj, dims=1:dimsToTry)
```

Check the names for the graphs in the seurat object.
```{r}
names(seuratObj@graphs)
```

The kNN graph is a matrix where every connection between cells is represented as a 1. This is called an unweighted graph (default in Seurat). Some cell connections can have more importance than others, in that case the scale of the graph goes from 0 to a maximum distance (it's these weights that are calculated based on the overlaps in local neighbourhoods). Usually, the smaller the distance, the closer two points are, the stronger is their connection. This is called a weighted graph. Both weighted and unweighted graphs are suitable for clustering, but clustering on unweighted graphs is faster for large datasets (> 100k cells).  

### Graph-based clustering
Then we are going to find clusters based on the neighbors info. Cells are iteratively grouped cells together. 

In Seurat, FindClusters() will do a graph-based clustering.

```{r}
resToUse <- 0.1 
```

Arguments for this function: 

- *object* Seurat object, input are the neighborhood graphs 
- *resolution*: how coarse you want the clustering to be. Higher values create more clusters. Recommendation here: try different values until you get a good tSNE/clustering with biologically meaningful results (between 0.4-1.2 for 3K cells).
- *algorithm* by default the "Louvain" algorithm is used for clustering (1). TO use the leiden algorithm, you need to set *algorithm*=4. 
- *graph.name* which graph to use: kNN or SNN

```{r}
seuratObj <- FindClusters(object=seuratObj, resolution=resToUse,graph.name="RNA_snn") 
```

The cluster data is stored in the metadata slot
```{r}
head(seuratObj@meta.data) 
```

### Questions
- Create a black and white heatmap using pheatmap() to show the connections between the 100 first cells in the matrix. Do not cluster cells, set fontsize to 2 and remove the borders of the tiles and the legend. The black dots on the graph represent connections between cells.
- Repeat clustering with resolution=0.8 

If you change dimsToTry and run the clustering again the old cluster data is overwritten  
If you change the resolution and run the clustering again the new cluster data is added to the metadata. The results of the last clustering will be used for downstream analysis.


## 17. Create tSNE plot
Dimensionality reduction using RunTSNE()  

Arguments of this function:  

- *object* Seurat object, input are typically the PCs
- *reduction* default use PCs obtained by PCA as input
- *dims* default use the first five PCs as input
- *check_duplicates* tSNE will generate an error "duplicates (cells with exactly the same PC coordinates) have to be removed before running tSNE" if there are duplicate cells in the data set. You can avoid this error by setting this parameter to FALSE.  

As input use the same PCs as in the clustering
```{r}
seuratObj <- RunTSNE(object=seuratObj,dims=1:dimsToTry,check_duplicates=FALSE)
```

```{r}
DimPlot(seuratObj,reduction="tsne",label=TRUE, label.size=8,pt.size=2) + NoLegend()
```

To color cells from different samples differently
```{r}
DimPlot(seuratObj,reduction="tsne",pt.size=2,group.by="sample")
```

### Questions
- Make a separate tSNE plot for KO and WT (on one graph).  
Hint: use one of the arguments of DimPlot()

## 18. Create UMAP plot
Dimensionality reduction using RunUMAP()  

Arguments of this function
- *object* Seurat object, input are typically the PCs
- *reduction* default use PCs obtained by PCA as input
- *dims* which PCs to use as input
- *n.components* default reduce to 2 dimensions
- *n.neighbors* parameter of the dimensionality reduction method. Larger values will preserve more global structure at the loss of detailed local structure. This parameter should be in the range 5 to 50, default is 30.
- *n.epochs* parameter of the dimensionality reduction method. Larger values result in higher accuracy. By default value will be selected based on the size of the input dataset (200 for large datasets, 500 for small).
- *min.dist* parameter of the dimensionality reduction method. How tightly can points be compressed together. Larger values ensure points are more evenly distributed, while smaller values allow to optimize more accurately with regard to local structure. Sensible values are in the range 0.001 to 0.5, default is 0.3
- *spread* parameter of the dimensionality reduction method. The effective scale of the points. In combination with *min.dist* this determines how clustered/clumped the points are.

```{r}
seuratObj <- RunUMAP(seuratObj,dims=1:dimsToTry)
```

Visualize UMAP plot, colored by sample to check for batch effects
```{r}
DimPlot(object=seuratObj,group.by="sample")
```

In a UMAP plot distances between clusters are more meaningful than in a tSNE plot.
```{r}
DimPlot(object=seuratObj,reduction="umap",label=TRUE,label.size=8) + NoLegend() + ggplot2::ggtitle(label="UMAP_on_PCA")
```

### Questions 
- Create a UMAP plot for the two samples separately on one graph. Set size of the points to 0.5. 
- Put PCA, tSNE and UMAP next to each other on one graph. Use NoAxes() to remove the axes from the plots and add a title to each plot: "PCA", "tSNE", "UMAP"
- Put MAP plots of the two clusterings (resolution 0.1 and 0.8) on one graph.  
Hint: look in the metadata to see how these columns are called.
- Use clustree() from the clustree package to visualize how cells are distributed between clusters depending on resolution.   
Hint: input = cluster info (in metadata), use  *prefix* argument to define columns with clusters

## 19. Interpret the clustering
Specify the clustering you want to use and print how many cells each cluster contains 

```{r}
#clust <- "RNA_snn_res.0.8"
#seuratObj <- SetIdent(seuratObj,value=clust)
table(seuratObj@active.ident)
```

Plot the clustering  

```{r}
p6 <- DimPlot(seuratObj,label=TRUE) + NoAxes()
p7 <- DimPlot(seuratObj,group.by="sample") + NoAxes()
ggarrange(p6,p7)
```

## 20. Save Seurat object 
Save object so that 

- it can easily be loaded back without having to rerun these computationally intensive steps  
- it's easy to share with collaborators  
```{r}
saveRDS(seuratObj,file="seuratObj.rds")
```

